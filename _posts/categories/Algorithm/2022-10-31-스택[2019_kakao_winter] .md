categories:
  - Algorithm

바로 풀이법을 보자.

## 🍧풀이법
```python
def solution(board, moves):
    answer = 0
    stack = []
    for i in range(len(moves)):
        for j in range(len(board)):
            if board[j][moves[i] - 1] != 0:
                stack.append(board[j][moves[i] - 1])
                board[j][moves[i] - 1] = 0
                print(stack)
                print()
                for brd in board:
                    print(brd)
                print()
                break
        if len(stack) >= 2 and stack[-1] == stack[-2]:
            stack.pop()
            stack.pop()
            answer += 2

    return print(answer)


board = [
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 3],
    [0, 2, 5, 0, 1],
    [4, 2, 4, 4, 2],
    [3, 5, 1, 3, 1]
]
moves = [1, 5, 3, 5, 1, 2, 1, 4]
solution(board, moves)
```

## 풀고 난 후기
자바였으면 바로바로 생각이 안 날 수도 있는데 파이썬 경우에는 생각하는대로 잘 풀려서 너무 좋았다.
물론 for문에 있어서 소프트코딩으로 리팩토링을 해보긴 해야 할 것이지만, 그래도 이정도면 괜찮다고 생각된다.
출력은 다음과 같다.

```
[4]

[0, 0, 0, 0, 0]
[0, 0, 1, 0, 3]
[0, 2, 5, 0, 1]
[0, 2, 4, 4, 2]
[3, 5, 1, 3, 1]

[4, 3]

[0, 0, 0, 0, 0]
[0, 0, 1, 0, 0]
[0, 2, 5, 0, 1]
[0, 2, 4, 4, 2]
[3, 5, 1, 3, 1]

[4, 3, 1]

[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 2, 5, 0, 1]
[0, 2, 4, 4, 2]
[3, 5, 1, 3, 1]

[4, 3, 1, 1]

[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 2, 5, 0, 0]
[0, 2, 4, 4, 2]
[3, 5, 1, 3, 1]

[4, 3, 3]

[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 2, 5, 0, 0]
[0, 2, 4, 4, 2]
[0, 5, 1, 3, 1]

[4, 2]

[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 0, 5, 0, 0]
[0, 2, 4, 4, 2]
[0, 5, 1, 3, 1]

[4, 2, 4]

[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 0, 5, 0, 0]
[0, 2, 4, 0, 2]
[0, 5, 1, 3, 1]

4

Process finished with exit code 0

```

## 고민 많이했던 부분
```python
if len(stack) >= 2 and stack[-1] == stack[-2]:
            stack.pop()
            stack.pop()
            answer += 2
```

이 부분이 애먹었던 부분이 아닐까 생각해본다.
len(stack) >= 2의 부분을 처음에는 i >= 2로 해서 위에서 돌리는 for문에서의 i를 인용한 것인데, 이렇게 되면 인덱스 범위를 넘어서게 되어서
안된다.

```python
stack[-1] == stack[-2]
``` 
이 부분도 사실은 stack[i] == stack[i-1]로 해서 i >= 2일때의 경우를 걸고 생각해봤으나 위에서 얘기한 인덱스 범위가 넘어서게 되어서 안된다.

## 결론
이 문제가 스택의 전형적인 예를 보여주는 것이 아닌가 생각해본다.
물론 괄호 문제들도 스택의 전형적인 예이지만, 스택 배열에 들어간 값이 같은지 확인 후 빼내는 방법을 응용한 부분에 있어서는 이 문제에서 제일 스택이라는 부분을 느낄 수 있었다.